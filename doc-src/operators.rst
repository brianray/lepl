
Operators
=========

.. index:: unsupported operand type, operators, BaseMatcher, SyntaxError

Caveats and Limitations
-----------------------

It is unfortunate, but realistic, that the chapter on operators should start
with some warnings to the user.

Operators --- things like ``&`` and ``|``, used to join matchers --- can help
produce grammars that are easy to read, easier to understand, and so less
likely to contain errors.  But their implementation pushes Python's
boundaries, giving problems with precedence and applicability.  This is
exacerbated by the automatic coercion of strings to ``Literal`` matchers
wherever possible.

For example, because operators effectively methods on "neighbouring" objects,
the following will fail::

  >>> name = ('Mr' | 'Ms') // Word()
  TypeError: unsupported operand type(s) for |: 'str' and 'str'

This is because neither ``'Mr'`` nor ``'Ms'`` subclass
``lepl.match.BaseMatcher`` (which is where ``|`` is defined, via ``__or__``
and ``__ror__``).

Another example, where precedence is not as we might hope::

  >>> name = ('Mr' // Word() > 'man' | 'Ms' // Word() > 'woman')
  SyntaxError: The operator > for And was applied to a matcher (<lepl.match.Or object at 0x7fbedc14a290>). Check syntax and parentheses.

because the expression is parsed by Python as::

  >>> name = ('Mr' // Word()) > ('man' | ('Ms' // Word()) > 'woman')

(the SyntaxError here is generated by LEPL, in an attempt to detect this kind
of error before the parser is called; it uses the ABC ``lepl.match.Matcher``
to identify matchers).

In short, then: use operators with care.  Many of the guidelines in the Style
chapter are intended to help manage these problems.


Catalogue
---------



Replacement
-----------

