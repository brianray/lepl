
Operators
=========


.. index:: unsupported operand type, operators, BaseMatcher, SyntaxError
.. _caveatsandlimitations:

Caveats and Limitations
-----------------------

It is unfortunate, but realistic, that the chapter on operators should start
with some warnings to the user.

Operators --- things like ``&`` and ``|``, used to join matchers --- can help
produce grammars that are easy to read, easier to understand, and so less
likely to contain errors.  But their implementation pushes Python's
boundaries, giving problems with precedence and applicability.  This is
exacerbated by the automatic coercion of strings to `Literal()
<api/redirect.html#lepl.matchers.Literal>`_ matchers wherever possible.

For example, because operators are effectively methods on *neighbouring
objects*, the following will fail::

  >>> name = ('Mr' | 'Ms') // Word()
  TypeError: unsupported operand type(s) for |: 'str' and 'str'

This is because neither ``'Mr'`` nor ``'Ms'`` subclass `BaseMatcher
<api/redirect.html#lepl.matchers.BaseMatcher>`_ (which is where ``|`` is
defined, via ``__or__`` and ``__ror__``).

Another example, where precedence is not as we might hope::

  >>> name = ('Mr' // Word() > 'man' | 'Ms' // Word() > 'woman')
  SyntaxError: The operator > for And was applied to a matcher (<lepl.matchers.Or object at 0x7fbedc14a290>). Check syntax and parentheses.

because the expression is parsed by Python as::

  >>> name = ('Mr' // Word()) > ('man' | ('Ms' // Word()) > 'woman')

(The SyntaxError here is generated by LEPL, in an attempt to detect this kind
of error before the parser is called; it uses the ABC `Matcher
<api/redirect.html#lepl.operators.Matcher>`_ to identify matchers.  It mentions
`And() <api/redirect.html#lepl.matchers.And>`_ because that is how ``//`` is
implemented.)

In short, then: use operators with care.  Many of the guidelines in the
:ref:`style` chapter are intended to help manage these problems.


Binary Operators Between Matchers
---------------------------------

========  ===========
Operator  Description
========  ===========
``&``     Joins matchers in sequence.  The result is a single list containing the results from all matchers.  Identical to `And() <api/redirect.html#lepl.matchers.And>`_.
--------  -----------
``+``     As ``&``, but the results are then joined together with the standard
          Python ``+`` operator.
--------  -----------
``/``     As ``&``, but with optional spaces (0 or more) between matchers.
          If no space is found, no result is added, otherwise any found
          spaces are joined together into a single result.
--------  -----------
``//``    As ``&``, but with required spaces (1 or more) between matchers.
          The spaces are joined together into a single result.
--------  -----------
``|``     Matches one matcher from a list.  The result is the result of the
          chosen matcher.  Identical to 
          `Or() <api/redirect.html#lepl.matchers.And>`_.
--------  -----------
``%``     As ``|``, but without backtracking between matchers.  
          Identical to `First() <api/redirect.html#lepl.matchers.First>`_.
========  ===========

For a discussion of backtracking see :ref:`backtracking`.


Prefix And Postfix Operators On Matchers
----------------------------------------

========  ===========
Operator  Description
========  ===========
``~``     Discards the result from the matcher. 
          Identical to `Drop() <api/redirect.html#lepl.matchers.And>`_.

--------  -----------
``[]``    Repeats the matcher, with optional concatenation and separator.
          Identical to `Repeat() <api/redirect.html#lepl.matchers.Repeat>`_.
========  ===========

.. note:

  `Lookahead() <api/redirect.html#lepl.matchers.And>`_ is an exception for
  ``~`` (see :ref:`lookahead`).


Operators That Apply Functions To Results
-----------------------------------------

========  ===========
Operator  Description
========  ===========
``>``     Pass the results of the matcher (left) to the given function (right) and use the result as the new result.  If the function is a string a ``(string, result)`` pair is generated instead.  Identical to `Apply() <api/redirect.html#lepl.matchers.Apply>`_.
--------  -----------
``>>``    As ``>``, but the function is applied to each result in turn 
          (instead of all results being supplied in a single list argument).
          Identical to `Map() <api/redirect.html#lepl.matchers.Map>`_.
--------  -----------
``*``     As ``>``, but the results are passed as ``*args`` (so each is
          received as a separate argument).
--------  -----------
``**``    As ``>``, but the results are passed as the named parameter 
          *results*.  Additional keyword arguments are *stream_in* (the
          stream passed to the matcher), *stream_out* (the stream returned
          from the matcher) and *core* (see :ref:`resources`).  
          Identical to `KApply() <api/redirect.html#lepl.matchers.KApply>`_.
--------  -----------
``^``     Raise a Syntax error.  The argument to the right is a string that
          is treated as a format template for the same named arguments as 
          ``**``.
========  ===========


.. _replacement:

Replacement
-----------

Operators can be replaced inside a ``with`` context using `Override()
<api/redirect.html#lepl.custom.Override>`_::

  >>> with Override(or_=And, and_=Or):
  >>>     abcd = (Literal('a') & Literal('b')) | ( Literal('c') & Literal('d'))
  >>>     print(abcd.parse_string('ac'))
  ['a', 'c']
  >>>     print(abcd.parse_string('ab'))
  None

(think about it).

It is also possible to provide a separator that is used for ``&`` and ``[]``.
With a little care (define matchers for characters before, and matchers for
sentences after, the *with* statement) this can handle the common case of
space--separated words in a transparent manner:

  >>> word = Letter()[:,...]
  >>> with Separator(r'\s+'):
  >>>     sentence = word[1:]
  >>> sentence.parse_string('hello world')
  ['hello', ' ', 'world']

Note that there was no need to specify a separator in ``word[1:]``, and that
this is a rare example of a string being coerced to something other than a
`Literal() <api/redirect.html#lepl.matchers.Literal>`_ (here `Regexp()
<api/redirect.html#lepl.matchers.Regexp>`_ is used).
