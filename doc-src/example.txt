Python 3.1 (r31:73572, Oct 24 2009, 05:39:09)                                  
[GCC 4.4.1 [gcc-4_4-branch revision 150839]] on linux2                         
Type "help", "copyright", "credits" or "license" for more information.         
>>> # Welcome to LEPL - a parser for Python 2.6+                              
...                                                                            
>>> # All these examples will assume that we have imported the main package    
... from lepl import *                                                         
>>>                                                                            
>>> # Let's start with a typical problem: we want to parse the input for       
... # a search engine.  A request might be:                                    
... #   spicy meatballs OR "el bulli restaurant"                               
...                                                                            
>>> # Here is how we define the parser:                                        
... word = ~Lookahead('OR') & Word()                                           
>>> phrase = String()                                                          
>>> with DroppedSpace():                                                       
...     text = (phrase | word)[1:] > list                                      
...     query = text[:, Drop('OR')]                                            
...                                                                            
>>> # and here is how we can use it:                                           
... query.parse('spicy meatballs OR "el bulli restaurant"')                    
[['spicy', 'meatballs'], ['el bulli restaurant']]                              
>>>                                                                            
>>> # If you want to pause this demo, so that you can scroll back and          
... # have a think, just click on the screen (click again to restart).         
...                                                                            
>>> # It's interesting to see what is happening in a little more detail:       
... with TrackVariables():                                                     
...     word = ~Lookahead('OR') & Word()                                       
...     phrase = String()                                                      
...     with DroppedSpace():                                                   
...         text = (phrase | word)[1:] > list                                  
...         query = text[:, Drop('OR')]                                        
...                                                                            
Warning! Cannot track: query = DepthFirst(0, None, rest=And, first=Transform)  
>>> query.parse('spicy meatballs OR "el bulli restaurant"')                    
      phrase failed                             stream = 'spicy meatballs OR...
        word = ['spicy']                        stream = 'spicy meatballs OR...
      phrase failed                             stream = 'meatballs OR "el b...
      word/2 = ['meatballs']                    stream = 'meatballs OR "el b...
      phrase failed                             stream = 'OR "el bulli resta...
      word/2 failed                             stream = 'OR "el bulli resta...
      phrase failed                             stream = ' OR "el bulli rest...
      word/2 failed                             stream = ' OR "el bulli rest...
        text = [['spicy', 'meatballs']]         stream = 'spicy meatballs OR...
      phrase = ['el bulli restaurant']          stream = '"el bulli restaura...
      phrase failed                             stream = ''
      word/2 failed                             stream = ''
      text/2 = [['el bulli restaurant']]        stream = '"el bulli restaura...
[['spicy', 'meatballs'], ['el bulli restaurant']]
>>> # The display above shows how the different variables are bound as
... # the input stream is consumed.  This can be very useful for debugging.
...
>>>
>>> # You probably noticed that some "surprising" syntax above, in the
... # way that we specify repeated matches - using [1:] for "one or more".
... # This may seem a little odd, but soon feels very natural.
...
>>> # For example, this means "between 3 and 5" (inclusive):
... Any()[3:5].parse('1234')
['1', '2', '3', '4']
>>> Any()[3:5].parse('123456')
No handlers could be found for logger "lepl.parser.trampoline"
Traceback (most recent call last):
[...]
lepl.stream.maxdepth.FullMatchException: The match failed at '6'.
>>>
>>> # And often, once we've matched something several times, we want to
... # join the results together - we can use [...] for that:
... Any()[3:5, ...].parse('1234')
['1234']
>>>
>>> # And (even more!) we can also specify a separator...
... Any()[3:5, ';'].parse('1;2;3;4')
['1', ';', '2', ';', '3', ';', '4']
>>> # ...which we often discard:
... Any()[3:5, Drop(';')].parse('1;2;3;4')
['1', '2', '3', '4']
>>>
>>> # While we're looking at LEPL's syntax, it's worth pointing out that
... # & and | do what you would expect:
... (Digit() | Letter())[:].parse('abc123')
['a', 'b', 'c', '1', '2', '3']
>>> (Digit() & Letter())[:].parse('1a')
['1', 'a']
PAUSE
CLEAR
