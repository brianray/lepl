Python 3.1 (r31:73572, Oct 24 2009, 05:39:09)
[GCC 4.4.1 [gcc-4_4-branch revision 150839]] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>>
>>> # Welcome to LEPL - a parser for Python 2.6+
... 
>>> # All these examples will assume that we have imported the main package
... from lepl import *
>>> 
>>> # Let's start with a typical problem: we want to parse the input for
... # a search engine.  A request might be:
... #   spicy meatballs OR "el bulli restaurant"
... 
>>> # Here is how we define the parser:
... word = ~Lookahead('OR') & Word()
>>> phrase = String()
>>> with DroppedSpace():
...     text = (phrase | word)[1:] > list
...     query = text[:, Drop('OR')]
... 
>>> # and here is how we can use it:
... query.parse('spicy meatballs OR "el bulli restaurant"')
[['spicy', 'meatballs'], ['el bulli restaurant']]
>>> 
>>> # If you want to pause this demo, so that you can scroll back and 
... # have a think, just click on the screen (click again to restart).
... 
>>> # It's interesting to see what is happening in a little more detail:
... with TrackVariables():
...     word = ~Lookahead('OR') & Word()
...     phrase = String()
...     with DroppedSpace():
...         text = (phrase | word)[1:] > list
...         query = text[:, Drop('OR')]
... 
Unfortunately the following matchers cannot be tracked:
  query = DepthFirst(0, None, rest=And, first=Transform)
>>> query.config.auto_memoize(full=True)
<lepl.core.config.ConfigBuilder object at 0xda1490>
>>> query.parse('spicy meatballs OR "el bulli restaurant"')
      phrase failed                             stream = 'spicy meatballs OR...
        word = ['spicy']                        stream = ' meatballs OR "el ...
      phrase failed                             stream = 'meatballs OR "el b...
        word = ['meatballs']                    stream = ' OR "el bulli rest...
      phrase failed                             stream = 'OR "el bulli resta...
        word failed                             stream = 'OR "el bulli resta...
      phrase failed                             stream = ' OR "el bulli rest...
        word failed                             stream = ' OR "el bulli rest...
        text = [['spicy', 'meatballs']]         stream = ' OR "el bulli rest...
      phrase = ['el bulli restaurant']          stream = ''
      phrase failed                             stream = ''
        word failed                             stream = ''
        text = [['el bulli restaurant']]        stream = ''
[['spicy', 'meatballs'], ['el bulli restaurant']]
>>> # The display above shows how the different variables are bound as
... # the input stream is consumed.  This can be very useful for debugging.
... 
>>> # Just before calling the parser above we configured full memoization.
... # This means that each matcher records previous matches and so avoids
... # earlier work.  The (lack of a) trace on a second call reflects this:
... query.parse('spicy meatballs OR "el bulli restaurant"')
[['spicy', 'meatballs'], ['el bulli restaurant']]
>>> # (the response appeared without calling any more matchers)
... 
>>> 
>>> # You probably noticed that some "surprising" syntax above, in the
... # way that we specify repeated matches - using [1:] for "one or more".
... # This may seem a little odd, but soon feels very natural.
... 
>>> # For example, this means "between 3 and 5" (inclusive):
... Any()[3:5].parse('1234')
['1', '2', '3', '4']
>>> Any()[3:5].parse('123456')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/core/config.py", line 767, in parse
    return self.null_parser(**kargs)(stream)
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/core/parser.py", line 229, in single
    return next(matcher(arg))[0]
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/core/parser.py", line 160, in trampoline
    raise value
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/core/parser.py", line 143, in trampoline
    value = stack[-1].generator.throw(value)
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/matchers/support.py", line 309, in _match
    value = yield generator
lepl.stream.maxdepth.FullMatchException: The match failed at '6'.
>>> # It's also common to use [:] or [0:] to mean "zero or more":
... Any()[:].parse('123456')
['1', '2', '3', '4', '5', '6']
>>> # (LEPL is greedy by default, and so matches as much as possible) 
... 
>>> # And often, once we've matched something several times, we want to
... # join the results together - we can use [...] for that:
... Any()[3:5, ...].parse('1234')
['1234']
>>> 
>>> # And (even more!) we can also specify a separator...
... Any()[3:5, ';'].parse('1;2;3;4')
['1', ';', '2', ';', '3', ';', '4']
>>> # ...which we often discard:
... Any()[3:5, Drop(';')].parse('1;2;3;4')
['1', '2', '3', '4']
>>> 
>>> # While we're looking at LEPL's syntax, it's worth pointing out that
... # & and | do what you would expect:
... (Digit() | Letter())[6].parse('abc123')
['a', 'b', 'c', '1', '2', '3']
>>> (Digit() & Letter()).parse('1a')
['1', 'a']
>>> 
>>> 
>>> # It's also easy to define your own matchers.  They can be as simple
... # as a single function:
... from string import ascii_uppercase
>>> 
>>> @function_matcher
... def Capital(support, stream):
...     if stream[0] in ascii_uppercase:
...         return ([stream[0]], stream[1:])
... # As you can see, a matcher takes a stream and, if the start of the
... # stream matches, returns that (in a list) and the rest of the stream.
... 
>>> # This works as you would expect:
... Capital().parse('A')
['A']
>>> Capital().parse('a')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/core/config.py", line 767, in parse
    return self.null_parser(**kargs)(stream)
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/core/parser.py", line 229, in single
    return next(matcher(arg))[0]
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/core/parser.py", line 160, in trampoline
    raise value
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/core/parser.py", line 143, in trampoline
    value = stack[-1].generator.throw(value)
  File "/home/andrew/projects/personal/src/lepl/trace/src/lepl/matchers/support.py", line 309, in _match
    value = yield generator
lepl.stream.maxdepth.FullMatchException: The match failed at 'a'.
>>> 
>>> 
>>> # So far we have focused mainly on recognising structure in text,
... # but parsing is also about processing that structure.
... 
>>> # We can process text as the text is matched by calling functions.
... # Each function takes a stream and a matcher:
... def print_text(result):
...     print('matched', result)
...     return list(result)
... 
>>> word = ~Lookahead('OR') & Word()
>>> phrase = String()
>>> with DroppedSpace():
...     text = (phrase | word)[1:] > print_text
...     query = text[:, Drop('OR')]
... 
>>> query.parse('spicy meatballs OR "el bulli restaurant"')
matched ['spicy', 'meatballs']
matched ['el bulli restaurant']
[['spicy', 'meatballs'], ['el bulli restaurant']]
>>> 
>>> # Another way LEPL can help with processing is by constructing a tree
... # (eg an AST).  To illustrate this, let's extend the original example
... # to include labelled parameters, like "site:acooke.org":
... 
>>> class Text(Node):
...     pass
... 
>>> class Parameter(Node):
...     pass
... 
>>> class Alternative(Node):
...     pass
... 
>>> word = ~Lookahead('OR') & Word()
>>> phrase = String()
>>> label = word & Drop(':') > 'label'
>>> value = (phrase | word) > 'value'
>>> with DroppedSpace():
...     parameter = label & value > Parameter
...     text = (phrase | word) > 'text'
...     alternative = (parameter | text)[1:] > Alternative
...     query = alternative[:, Drop('OR')]
... 
>>> result = query.parse('word "a phrase" OR that OR this site:within.site')
>>> 
>>> # Each alternative is a separate tree
... for alt in result:
...     print(str(alt))
... 
Alternative
 +- text 'word'
 `- text 'a phrase'
Alternative
 `- text 'that'
Alternative
 +- text 'this'
 `- Parameter
     +- label 'site'
     `- value 'within.site'
>>> 
>>> # and tree members can be accessed directly:
... result[2].Parameter[0].label[0]
PAUSE
CLEAR
