
Closing Remarks
===============

This chapter contains various observations, comments, etc, that didn't fit
elsewhere in the documentation.


.. _backtracking:

Search and Backtracking
-----------------------

Since LEPL supports full backtracking via generators it is possible to request
all the alternative parses for a given input::

  >>> from lepl import *

  >>> any = Any()[:,...]
  >>> split = any & any & Eos()
  >>> match = split.string_matcher()

  >>> [pair[0] for pair in match('****')]
  [['****'], ['***', '*'], ['**', '**'], ['*', '***'], ['****']]

This shows that successive parses match less of the input with the first
option, indicating that the matching is *greedy*.

*Non-greedy* (generous?) matching is achieved by specifying an array slice
increment of ``'b'`` (or `BREADTH_FIRST
<api/redirect.html#lepl.match.BREADTH_FIRST>`_)::

  >>> any = Any()[::'b',...]
  >>> split = any & any & Eos()
  >>> match = split.string_matcher()

  >>> [pair for (pair, stream) in match('****')]
  [['****'], ['*', '***'], ['**', '**'], ['***', '*'], ['****']]

The greedy and non--greedy repetitions are implemented by depth (default,
``'d'``, or `DEPTH_FIRST <api/redirect.html#lepl.match.DEPTH_FIRST>`_),
and breadth--first searches (``'b'`` or `BREADTH_FIRST
<api/redirect.html#lepl.match.BREADTH_FIRST>`_), respectively.

In addition, by specifying a slice increment of ``'g'`` (`GREEDY
<api/redirect.html#lepl.match.GREEDY>`_), you can request a *guaranteed
greedy* match.  This evaluates all possibilities, before returning them in
reverse length order.  Typically this will be identical to depth--first
search, but it is possible for backtracking to produce a longer match in
complex cases --- this final option, by evaluating all cases, re--orders the
results as necessary.

Specifying ``'n'`` (`NON_GREEDY
<api/redirect.html#lepl.match.NON_GREEDY>`_) gets the reverse ordering.

The tree implicit in the descriptions "breadth--first" and "depth--first" is
not the AST, nor the tree of matchers, but a tree based on matchers and
streams.  In the case of a single, repeated, match this is easy to visualise:
at any particular node the child nodes are generated by applying the matcher
to the various streams returned by the current match (none if this is a final
node, one for a simple match, several if the matcher backtracks).

So far so good.  Unfortunately the process is more complicated for `And()
<api/redirect.html#lepl.match.And>`_ and `Or()
<api/redirect.html#lepl.match.Or>`_.

In the case of `And() <api/redirect.html#lepl.match.And>`_, the first
matcher is matched first.  The child nodes correspond to the various (with
backtracking) results of this match.  At each child node, the second matcher
is applied, generating new children.  This repeats until the scope of the
`And() <api/redirect.html#lepl.match.And>`_ terminates at a depth in the
tree corresponding to the children of the last matcher.  Since `And()
<api/redirect.html#lepl.match.And>`_ fails unless all matchers match, only
the final child nodes are possible results.  As a consequence, both breadth
and depth first searches would return the same ordering.  The `And()
<api/redirect.html#lepl.match.And>`_ match is therefore unambiguous and the
implementation has no way to specify the (essentially meaningless) choice
between the two searches.

In the case of `Or() <api/redirect.html#lepl.match.Or>`_ we must select
both the matcher and the result from the results available for that matcher.
A natural approach is to assign the first generation of children to the choice
of matcher, and the second level to the choice of result for the (parent)
matcher.  Again, this results in no ambiguity between breadth and depth--first
results.

However, there is also an intuitively attractive argument that breadth--first
search would return the first results of the different matches, in series,
before considering backtracking.  At the moment I do not see a "natural" way
to form such a tree, and so this is not implemented.  Feedback is appreciated.


.. index:: Tim Peters, Sam Wilmott, Pattern Matching in Python, Guy Cousineau,
           Michel Mauny, PyParsing, Paul McGuire

Credits
-------

Blame Tim Peters' `test_generators.py
<http://www.koders.com/python/fid9B99238B5452E1EDA851459C2F4B5FD19ECBAD17.aspx?s=mdef%3Amd5>`_
for starting me thinking about this, but that would have got nowhere without
Sam Wilmott's `Pattern Matching in Python
<http://www.wilmott.ca/python/patternmatching.html>`_ from which I have stolen
almost everything (well, a large chunk of LEPL 1.0, including the repetition
syntax).

`PyParsing <http://pyparsing.wikispaces.com/>`_ was also a major motivation
(if you don't like the way LEPL handles spaces, you may prefer Paul McGuire's
package which is, I think, pretty much the standard for simple, recursive
descent Python parsers).

Thanks to `Guy Cousineau and Michel Mauny
<http://books.google.cl/books?hl=en&id=-vQPDXciXUMC&dq=cousineau+mauny>`_ for
the original education.

David Eppstein's `DFS code <http://www.ics.uci.edu/~eppstein/PADS/DFS.py>`_
strongly influenced `dfs_edges() <api/redirect.html#lepl.graph.dfs_edges>`_.
Thanks for putting that on the web.


.. index:: futile despair

Endnote
-------

LEPL was written as Israel, with the implicit support of the USA, largely
destroyed Gaza.
